<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: layer.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: layer.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>(function () {
    "use strict";

    /**
     * Create a new Layer. Layers can be nested inside of states or screens.
     * @class HYPER.Layer
     * @param {object} e Object to pass all Layer info.
     * @param {string} e.canvas Id of the canvas you want used as the game Layer.
     * @param {boolean} e.antiAliasing=false Whether or not the canvas should use canvas antiAliasing.
     * @param {boolean} e.autoClear=false Whether or not the canvas should clear itself before every frame.
     * @param {boolean} e.smartRendering=false Whether or not to render objects not shown on the Layer.
     * @param {boolean} e.motionBlur=false Whether or not motion blur is enabled.
     * @param {boolean} e.showFPS=false Whether or not to show the current FPS.
     * @param {function} e.render Custom rendering directions for the Layer.
     * @param {function} e.update Custom updating directions for the Layer.
     * @param {function} e.onClick What happens when someone clicks.
     * @param {function} e.onUp What happens when someone clicks up.
     * @param {function} e.onDown What happens when someone clicks down.
     * @param {function} e.onDblClick What happens when someone double clicks.
     * @param {function} e.onKeyUp What happens when a key is lifted.
     * @param {function} e.onKeyDown What happens when a key is pressed.
     * @param {function} e.onKeyHeld What happens when a key is held.
     * @param {number} e.fps fps the game will be rendered and updated at.
     * @param {object} e.camera The camera object, change the position and view to change what is shown.
     * @param {number} e.camera.x=0 X location of the camera.
     * @param {number} e.camera.y=0 Y location of the camera.
     * @param {number} e.camera.width=1280 Width of the camera.
     * @param {number} e.camera.height=720 Height of the camera.
     * @param {object} e.view The view object, change the position and view of the Layer on the webpage.
     * @param {number} e.view.x=0 X location of the Layer.
     * @param {number} e.view.y=0 Y location of the Layer.
     * @param {number} e.view.width=1280 Width of the Layer.
     * @param {number} e.view.height=720 Height of the Layer.
     */

    HYPER.Layer = function (e) {
        e = e || {};
        e.camera = e.camera || {};
        e.view = e.view || {};
        var that = this;

        /**
         * @property {string} _ID - The specific ID for this object.
         */

        this._ID = "Layer " + Math.random() + "" + Math.random();

        /**
         * @property {object} style - The style used for this object.
         */

        this.style = e.style || HYPER.Graphics.DEFAULT_STYLE;

        /**
         * @property {object} canvas - The canvas that all children are rendered directly to.
         */

        this.canvas = document.createElement("canvas");

        /**
         * @property {object} canvas - The ctx of the canvas that all children are rendered directly to.
         */

        this.ctx = this.canvas.getContext("2d");

        /**
         * @property {object} lastcanvas - The canvas that is used for motion blur.
         */

        this.lastcanvas = document.createElement("canvas");

        /**
         * @property {object} lastctx - The ctx that is used for motion blur.
         */

        this.lastctx = this.lastcanvas.getContext("2d");


        /**
         * @private
         * @property {function} _tick - stores all update speed settings.
         */

        this._tick = {
            FPS: e.tickFPS || e.tickfps || e.fps || 30,
            _now: 0,
            _then: Date.now(),
            _interval: 1000 / 30,
            _delta: 0,
        };

        /**
         * @private
         * @property {function} _anime - stores all rendering speed settings.
         */

        this._anime = {
            FPS: e.animeFPS || e.animefps || e.fps || 60,
            _now: 0,
            _then: Date.now(),
            _interval: 1000 / 60,
            _delta: 0,
        };

        /**
         * @property {string} backgroundColor - Background color of the Layer.
         */

        this.backgroundColor = e.backgroundColor || "#000000";

        /**
         * @property {string} backgroundColor - Background color of the Layer.
         */

        this.antiAliasing = e.antiAliasing || false;

        /**
         * @property {boolean} autoClear - Whether or not to clear the canvas before every frame.
         */

        this.autoClear = e.autoClear || false;

        /**
         * @property {boolean} smartRendering - Whether or not to render objects that are not on the screen.
         */

        this.smartRendering = e.smartRendering || false;

        /**
         * @property {boolean} motionBlur - Whether or not to render objects with a motion blur.
         */

        this.motionBlur = e.motionBlur || false;

        /**
         * @property {object} camera - The camera object, change the position and view to change what is shown.
         */

        this.camera = {
            /**
             * @property {number} camera.x - X location of the camera.
             */
            x: e.camera.x || 0,
            /**
             * @property {number} camera.y - Y location of the camera.
             */
            y: e.camera.y || 0,
            /**
             * @property {number} camera.width - Width of the camera.
             */
            width: e.camera.width || 1280,
            /**
             * @property {number} camera.height - Height of the camera.
             */
            height: e.camera.height || 720,
        };


        /**
         * @property {object} view - The object on the screen.
         */

        this.view = {
            /**
             * @property {number} view.x - X location on the screen.
             */
            x: e.view.x || 0,
            /**
             * @property {number} view.y - Y location on the screen.
             */
            y: e.view.y || 0,
            /**
             * @property {number} view.width - Width on the screen.
             */
            width: e.view.width || 1280,
            /**
             * @property {number} view.height - Height on the screen.
             */
            height: e.view.height || 720,
        };

        /**
         * @property {object} passedINFO - Info that is passed to children every loop.
         */

        this.passedINFO = {
            pointerDATA: [],
        };

        /**
         * @property {array} pointerDATA - pointer data that is passed to children every loop.
         */

        this.pointerDATA = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}];

        /**
         * @property {array} children - Array of all children in the screen.
         */

        this.children = [];

        /**
         * @property {array} children - Whether or not to use z-index when rendering.
         */

        this.enableZindex = e.enableZindex || false;

        /**
         * @property {function} render - user defined function that is called at the end of every frame.
         */

        this.render = e.render || no0p;

        /**
         * @property {function} update - user defined function that is called at the end of every tick.
         */

        this.update = e.update || no0p;

        /**
         * @property {function} update - user defined function that is called when the object is initalized.
         */

        this.init = e.init || no0p;

        /**
         * @property {function} onClick - Function that is called every time the screen is clicked.
         */

        this.onClick = e.onClick || no0p;

        /**
         * @property {function} onUp - Function that is called every time the screen is clicked up.
         */

        this.onUp = e.onUp || no0p;

        /**
         * @property {function} onDown - Function that is called every time the screen is clicked down.
         */

        this.onDown = e.onDown || no0p;

        /**
         * @property {function} onHold - Function that is called every tick the screen is being clicked by the mouse pointer.
         */

        this.onHold = e.onHold || no0p;

        /**
         * @property {function} onDblClick - Function that is called every time the screen is double clicked.
         */

        this.onDblClick = e.onDblClick || no0p;

        /**
         * @property {function} onKeyUp - Function that is called every time a key is lifted.
         */

        this.onKeyUp = e.onKeyUp || no0p;

        /**
         * @property {function} onKeyDown - Function that is called every time a key is pushed.
         */

        this.onKeyDown = e.onKeyDown || no0p;

        /**
         * @property {function} onKeyHeld - Function that is called every time a key is held down.
         */

        this.onKeyHeld = e.onKeyHeld || no0p;




    };

    HYPER.Layer.prototype = {

        /**
         * Sets the update FPS of the object. Note that this is the fastest all children can also update.
         * @method HYPER.Layer.setTickFPS
         * @param {number} fps - The desired FPS.
         */

        setTickFPS: function (fps) {
            this._tick.FPS = fps;
            this._tick._interval = 1000 / this._tick.FPS;
        },

        /**
         * Sets the update FPS of the screen. Note that this is the fastest all children can also render.
         * @method HYPER.Layer.setAnimeFPS
         * @param {number} fps - The desired FPS.
         */

        setAnimeFPS: function (fps) {
            this._anime.FPS = fps;
            this._anime._interval = 1000 / this._anime.FPS;
        },

        /**
         * Adds children to the object.
         * @method HYPER.Layer.addChild
         * @param {object} child - The child you want to add.
         */

        addChild: function (child) {
            this.children.push(child);
        },

        /**
         * Removes children from the object.
         * @method HYPER.Layer.removeChild
         * @param {object} child - The child you want to remove.
         */

        removeChild: function (child) {
            for (let c = 0; c &lt; this.children.length; c++) {
                if (child._ID === this.children[c]._ID) {
                    this.children.splice(c, 1);
                };
            };
        },

        /**
         * Removes all children from the object.
         * @method HYPER.Layer.removeAllChildren
         */

        removeAllChildren: function () {
            this.children = [];
        },

        /**
         * updates the renderer.
         * @private
         * @method HYPER.Layer._updateRender
         * @param {object} a - Rendering info.
         */

        _updateRender: function (a) {
            if (this.backgroundColor === "clear" || this.autoClear) {

                HYPER.Graphics.Draw(this.ctx)
                    .clearRect(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height);


            } else {

                HYPER.Graphics.Draw(this.ctx)
                    .setFillColor(this.backgroundColor)
                    .rect(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height);

            }

        },

        /**
         * renders the children.
         * @private
         * @method HYPER.Layer._renderChildren
         * @param {object} a - Rendering info.
         */

        _renderChildren: function (a) {
            if (this.enableZindex === true) {
                // Loop through all z-indexes
                for (let z = 0; z &lt; this.children.length; z++) {
                    // Loop through all children
                    for (let i = 0; i &lt; this.children.length; i++) {
                        // Check to see if the z-index is correct.
                        if (Math.round(this.children[i].zIndex) === z) {
                            // Check to see if smart rendering is turned on.
                            if (this.smartRendering === true) {
                                // Check to see if the desplayed object overlaps the screen.
                                if (HYPER.Physics.checkAABBCollision(this.view, this.children[i])) {
                                    this.children[i]._render(this.passedINFO);
                                }
                            } else {
                                this.children[i]._render(this.passedINFO);
                            }
                        }
                    }
                }
            } else {
                // loop through all children
                for (let i = 0; i &lt; this.children.length; i++) {
                    // Check to see if smart rendering is turned on.
                    if (this.smartRendering === true) {
                        // Check to see if the desplayed object overlaps the screen.
                        if (HYPER.Physics.checkAABBCollision(this.view, this.children[i])) {
                            // render child
                            this.children[i]._render(this.passedINFO);
                        }
                    } else {
                        // render child
                        this.children[i]._render(this.passedINFO);
                    }
                }
            }
        },

        /**
         * Updates the children.
         * @private
         * @method HYPER.Layer._updateChildren
         * @param {object} a - Updating info.
         */

        _updateChildren: function (a) {
            // loop through all children.
            for (let i = 0; i &lt; this.children.length; i++) {
                //update child
                this.children[i]._update(this.passedINFO);


            }
        },

        /**
         * Updates the pointers.
         * @private
         * @method HYPER.Layer._updatePointerData
         * @param {object} a - Updating info.
         */

        _updatePointerData: function (a) {
            //console.log(this);
            for (var i = 0; i &lt; 1; i++) {

                this.pointerDATA[i].trueX = a.pointerDATA[i].x - this.view.x + this.camera.x;
                this.pointerDATA[i].trueY = a.pointerDATA[i].y - this.view.y + this.camera.y;
                this.pointerDATA[i].scaleFactorX = this.camera.width / this.view.width;
                this.pointerDATA[i].scaleFactorY = this.camera.height / this.view.height;
                this.pointerDATA[i].x = this.pointerDATA[i].trueX * this.pointerDATA[i].scaleFactorX - this.camera.x;
                this.pointerDATA[i].y = this.pointerDATA[i].trueY * this.pointerDATA[i].scaleFactorY - this.camera.y;

                this.pointerDATA[i].down = HYPER.Input.Pointer.point[i].down;
                this.pointerDATA[i].up = HYPER.Input.Pointer.point[i].up;
                this.pointerDATA[i].dblclick = HYPER.Input.Pointer.point[i].dblclick;
                this.pointerDATA[i].hold = HYPER.Input.Pointer.point[i].hold;
                this.pointerDATA[i].click = HYPER.Input.Pointer.point[i].down;

            }
            this.passedINFO.pointerDATA = this.pointerDATA;
        },

        /**
         * Updates the pointers based on the id.
         * @private
         * @method HYPER.Layer.updatePointerDATA_ID
         * @param {object} a - Updating info.
         */

        updatePointerDATA_ID: function (DATA, i) {
            this.pointerDATA[i].trueX = DATA.x - this.view.x + this.camera.x;
            this.pointerDATA[i].trueY = DATA.y - this.view.y + this.camera.y;
            this.pointerDATA[i].scaleFactorX = this.camera.width / this.view.width;
            this.pointerDATA[i].scaleFactorY = this.camera.height / this.view.height;
            this.pointerDATA[i].x = this.pointerDATA[i].trueX * this.pointerDATA[i].scaleFactorX - this.camera.x;
            this.pointerDATA[i].y = this.pointerDATA[i].trueY * this.pointerDATA[i].scaleFactorY - this.camera.y;

            this.pointerDATA[i].down = HYPER.Input.Pointer.point[i].down;
            this.pointerDATA[i].up = HYPER.Input.Pointer.point[i].up;
            this.pointerDATA[i].dblclick = HYPER.Input.Pointer.point[i].dblclick;
            this.pointerDATA[i].hold = HYPER.Input.Pointer.point[i].hold;
            this.pointerDATA[i].click = HYPER.Input.Pointer.point[i].down;
        },

        /**
         * Updates the info that is passed to the children.
         * @private
         * @method HYPER.Layer._updatePassedInfo
         * @param {object} a - Updating info.
         */

        _updatePassedInfo: function (a) {
            this.passedINFO.canvas = this.canvas;
            this.passedINFO.ctx = this.ctx;
            this.passedINFO.view = this.view;
            this.passedINFO.camera = this.camera;

            this._updatePointerData(a);
        },

        /**
         * Updates the settings used for rendering.
         * @private
         * @method HYPER.Layer._updateRenderingSettings
         * @param {object} a - Updating info.
         */

        _updateRenderingSettings: function (a) {

            if (this.camera.width != this.canvas.width ||
                this.camera.height != this.canvas.height) {
                this.canvas.width = this.camera.width;
                this.canvas.height = this.camera.height;

            }
            if (this.camera.width != this.lastcanvas.width ||
                this.camera.height != this.lastcanvas.height) {
                this.lastcanvas.width = this.camera.width;
                this.lastcanvas.height = this.camera.height;

            }
            // Set smooth Pixels
            if (this.ctx.mozImageSmoothingEnabled != this.antiAliasing) {
                this.ctx.mozImageSmoothingEnabled = this.antiAliasing;
            }
            if (this.ctx.webkitImageSmoothingEnabled != this.antiAliasing) {
                this.ctx.webkitImageSmoothingEnabled = this.antiAliasing;
            }
            if (this.ctx.msImageSmoothingEnabled != this.antiAliasing) {
                this.ctx.msImageSmoothingEnabled = this.antiAliasing;
            }
            if (this.ctx.imageSmoothingEnabled != this.antiAliasing) {
                this.ctx.imageSmoothingEnabled = this.antiAliasing;
            }


            if (this.antiAliasing == false &amp;&amp; this.canvas.style.imageRendering != "pixelated") {
                this.canvas.style.imageRendering = "pixelated";
            } else if (this.antiAliasing == true &amp;&amp; this.canvas.style.imageRendering != "auto") {
                this.canvas.style.imageRendering = "auto";
            }
            this._updateRender(a);

        },

        /**
         * Called on the click event.
         * @private
         * @method HYPER.Layer._onClick
         */

        _onClick: function (data) {
            this.updatePointerDATA_ID(data, data._ID);
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onClick) {
                        this.children[i]._onClick(this.pointerDATA[data._ID]);
                    }
                }
            }
            this.onClick(this.pointerDATA[data._ID]);
        },

        /**
         * Called on the mouse up event.
         * @private
         * @method HYPER.Layer._onUp
         */

        _onUp: function (data) {
            this.updatePointerDATA_ID(data, data._ID);
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onUp) {
                        this.children[i]._onUp(this.pointerDATA[data._ID]);
                    }
                }
            }
            this.onUp(this.pointerDATA[data._ID]);
        },

        /**
         * Called on the mouse down event.
         * @private
         * @method HYPER.Layer._onDown
         */

        _onDown: function (data) {
            this.updatePointerDATA_ID(data, data._ID);
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onDown) {
                        this.children[i]._onDown(this.pointerDATA[data._ID]);
                    }
                }
            }
            this.onDown(this.pointerDATA[data._ID]);
        },

        /**
         * Called when the mouse pointer is held down.
         * @private
         * @method HYPER.Layer._onHold
         */

        _onHold: function (data) {
            this.updatePointerDATA_ID(data, data._ID);
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onHold) {
                        this.children[i]._onHold(this.pointerDATA[data._ID]);
                    }
                }
            }
            this.onHold(this.pointerDATA[data._ID]);
        },

        /**
         * Called when the user double clicks.
         * @private
         * @method HYPER.Layer._onDblClick
         */

        _onDblClick: function (data) {
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onDblClick) {
                        this.children[i]._onDblClick(this.pointerDATA[data._ID]);
                    }
                }
            }
            this.onDblClick(this.pointerDATA[data._ID]);
        },

        /**
         * Called on the key down.
         * @private
         * @method HYPER.Layer._onKeyDown
         */

        _onKeyDown: function (data) {
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onKeyDown) {
                        this.children[i]._onKeyDown(data);
                    }
                }
            }
            this.onKeyDown(data);
        },

        /**
         * Called when a key is held down.
         * @private
         * @method HYPER.Layer._onKeyHeld
         */

        _onKeyHeld: function (data) {
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onKeyHeld) {
                        this.children[i]._onKeyHeld(data);
                    }
                }
            }
            console.log("hi")
            this.onKeyHeld(data);
        },

        /**
         * Called on the key up.
         * @private
         * @method HYPER.Layer._onKeyUp
         */

        _onKeyUp: function (data) {
            for (let i = 0; i &lt; this.children.length; i++) {
                if (this.children[i].alive) {
                    if (this.children[i]._onKeyUp) {
                        this.children[i]._onKeyUp(data);
                    }
                }
            }
            this.onKeyUp(data);
        },

        /**
         * Called every frame.
         * @private
         * @method HYPER.Layer._render
         */

        _render: function (a) {
            this._anime._now = Date.now();
            this._anime._delta = this._anime._now - this._anime._then;

            if (this._anime._delta > this._anime._interval) {

                this._anime._then = this._anime._now - (this._anime._delta % this._anime._interval);



                if (this.backgroundColor === "clear" || this.autoClear) {


                    HYPER.Graphics.Draw(a.ctx)
                        .clearRect(
                            0,
                            0,
                            a.canvas.width,
                            a.canvas.height);


                }




                if (this.motionBlur) {

                    HYPER.Graphics.Draw(a.ctx, this.style)
                        .bitmap(
                            this.canvas,
                            0,
                            0,
                            this.camera.width,
                            this.camera.height,
                            this.view.x,
                            this.view.y,
                            this.view.width,
                            this.view.height);

                }

                this._updateRenderingSettings(a);
                this._updatePassedInfo(a);
                this._renderChildren(this.passedINFO);

                this.render(this.passedINFO);




                if (this.motionBlur) {

                    HYPER.Graphics.Draw(a.ctx, this.style)
                        .setAlpha(this.style.alpha / 2)
                        .bitmap(
                            this.canvas,
                            0,
                            0,
                            this.camera.width,
                            this.camera.height,
                            this.view.x,
                            this.view.y,
                            this.view.width,
                            this.view.height);


                } else {

                    HYPER.Graphics.Draw(a.ctx, this.style)
                        .bitmap(
                            this.canvas,
                            0,
                            0,
                            this.camera.width,
                            this.camera.height,
                            this.view.x,
                            this.view.y,
                            this.view.width,
                            this.view.height);
                };


            };
        },

        /**
         * Called every tick.
         * @private
         * @method HYPER.Layer._update
         */

        _update: function (a) {
            this._tick._now = Date.now();
            this._tick._delta = this._tick._now - this._tick._then;
            if (this._tick._delta > this._tick._interval) {
                this._tick._then = this._tick._now - (this._tick._delta % this._tick._interval);

                // Game Code
                this._updatePassedInfo(a);

                this._updateChildren(this.passedINFO);
                this.update(this.passedINFO);
                // End Game Code

            }
        },

        /**
         * Called when the Layer is initalized.
         * @method HYPER.Layer._init
         */

        _init: function () {
            this.init();
        },
    };


})();</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="HYPER.Audio.Howl.html">Howl</a></li><li><a href="HYPER.Audio.HowlerGlobal.html">HowlerGlobal</a></li><li><a href="HYPER.Audio.Sound.html">Sound</a></li><li><a href="HYPER.Button.html">Button</a></li><li><a href="HYPER.Graphics.Animation.html">Animation</a></li><li><a href="HYPER.Graphics.Bitmap.html">Bitmap</a></li><li><a href="HYPER.Graphics.Draw.html">Draw</a></li><li><a href="HYPER.Graphics.SpriteSheet.html">SpriteSheet</a></li><li><a href="HYPER.Graphics.Style.html">Style</a></li><li><a href="HYPER.Group.html">Group</a></li><li><a href="HYPER.Layer.html">Layer</a></li><li><a href="HYPER.Particle.Emitter.html">Emitter</a></li><li><a href="HYPER.Particle.Particle.html">Particle</a></li><li><a href="HYPER.Physics.BoxJS.Box.html">Box</a></li><li><a href="HYPER.Physics.BoxJS.Engine.html">Engine</a></li><li><a href="HYPER.Physics.BoxJS.material.html">material</a></li><li><a href="HYPER.Physics.BoxJS.Vector2.html">Vector2</a></li><li><a href="HYPER.Preload.Audio.html">Audio</a></li><li><a href="HYPER.Preload.Bitmap.html">Bitmap</a></li><li><a href="HYPER.Preload.SpriteSheet.html">SpriteSheet</a></li><li><a href="HYPER.Screen.html">Screen</a></li><li><a href="HYPER.Sprite.html">Sprite</a></li><li><a href="HYPER.State.html">State</a></li></ul><h3>Namespaces</h3><ul><li><a href="HYPER.html">HYPER</a></li><li><a href="HYPER.Graphics.html">Graphics</a></li><li><a href="HYPER.Input.html">Input</a></li><li><a href="HYPER.Input.Keys.html">Keys</a></li><li><a href="HYPER.Input.Pointer.html">Pointer</a></li><li><a href="HYPER.Math.html">Math</a></li><li><a href="HYPER.Particle.html">Particle</a></li><li><a href="HYPER.Physics.html">Physics</a></li><li><a href="HYPER.Physics.BoxJS.html">BoxJS</a></li><li><a href="HYPER.Physics.Vector.html">Vector</a></li><li><a href="HYPER.Preload.html">Preload</a></li></ul><h3>Global</h3><ul><li><a href="global.html#mobileAndTabletcheck">mobileAndTabletcheck</a></li><li><a href="global.html#no0p">no0p</a></li><li><a href="global.html#setFPS">setFPS</a></li><li><a href="global.html#Timer">Timer</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.1</a> on Wed Oct 12 2016 14:38:12 GMT-0700 (US Mountain Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
